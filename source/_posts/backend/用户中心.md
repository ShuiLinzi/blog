---
title: 用户登录权限相关
date: 2022-04-08
---
# 前后端分离token验证
:::primary
jwt token 常在请求头中进行传递，前端可以保存在cookie中，然后前端发送请求的时候从cookie中取出，放在请求头中发送请求，后端可以直接从请求中`request.getHead("token")`获取到token
:::

:::danger
前后端分离不代表就不能用session验证是否登录，但是会出现分布式session共享问题。
面试题常考：详细介绍一下JWT，除了JWT方式外，还有什么鉴权方式？JWT方式鉴权和Session-Cookie方式鉴权方式的对比及优缺点？前后端分离就不能使用Session-Cookie吗？
:::

token验证完整流程

![jwt流程](https://cdn.jsdelivr.net/gh/ShuiLinzi/blog-image@master/后端/jwt流程.webp)
详细流程如图所示
细节①：当访问需要登录之后才有的接口时候，需要走拦截器，判断是否携带了token，是否登录，如果为携带不放行，并让此登录
细节②：由于用户访问用户相关api的时候会一直走token，可能会出现登录的时候token未失效但是后面一直在逛购物车，逛订单首页，然后token失效了，所系需要进行刷新token

**优化**:可以在登录的时候把生成的token返回给前端的同时，也存放到redis中，这样注入`HttpSeveletRequest`,然后获取token，就可以直接查redis，然后得到userid了！

至于id，交给前端传递了！

注销就把token给失效掉就ok了

过滤器（`Filter`）：当你有一堆东西的时候，你只希望选择符合你要求的某一些东西。定义这些要求的工具，就是过滤器。

拦截器（`Interceptor`）：在一个流程正在进行的时候，你希望干预它的进展，甚至终止它进行，这是拦截器做的事情。

监听器（`Listener`）：当一个事件发生的时候，你希望获得这个事件发生的详细信息，而并不想干预这个事件本身的进程，这就要用到监听器。


```java spring拦截器的实现方法
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;

public class OldLoginInterceptor extends HandlerInterceptorAdapter {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
            throws Exception {

        System.out.println("\n-------- OldLoginInterceptor.preHandle --- ");
        System.out.println("Request URL: " + request.getRequestURL());
        System.out.println("Sorry! This URL is no longer used, Redirect to /admin/login");

        response.sendRedirect(request.getContextPath() + "/admin/login");
        return false;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, //
                           Object handler, ModelAndView modelAndView) throws Exception {

        // This code will never be run.
        System.out.println("\n-------- OldLoginInterceptor.postHandle --- ");
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, //
                                Object handler, Exception ex) throws Exception {

        // This code will never be run.
        System.out.println("\n-------- QueryStringInterceptor.afterCompletion --- ");
    }

}
```

```java JavaServlet自带的过滤器实现
//要在主启动类中加@ServletComponentScan 注解进行扫描
@WebFilter(filterName = "MyFilterWithAnnotation", urlPatterns = "/api/*")
public class MyFilterWithAnnotation implements Filter {

   ......
}
```
# 前后端不分离
一般使用 `request.getSession().getAttribute()`操作相关的session进行验证
# 参考文章
[spring boot 过滤器和拦截器](https://www.cnblogs.com/JonaLin/p/12711146.html)

[spring boot 过滤器和拦截器—Java Guide](https://snailclimb.gitee.io/springboot-guide/#/./docs/basis/springboot-interceptor?id=_2%e8%bf%87%e6%bb%a4%e5%99%a8%e5%92%8c%e6%8b%a6%e6%88%aa%e5%99%a8%e7%9a%84%e5%8c%ba%e5%88%ab)