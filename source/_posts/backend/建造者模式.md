---
title: 设计模式~创建型~建造者模式
date: 2022-4-30
tags:
- 设计模式
- Java
categories:
    - [学习笔记, 设计模式]
---
# 建造者模式（Builder）（生成器）
[建造者模式详解](https://www.jianshu.com/p/5d34a496e517)
[](https://www.jianshu.com/p/be290ccea05a)
## 思考
### 与工厂模式有何区别？
1. 建造者模式是让建造者类来负责对象的创建工作。上面讲到的工厂模式，是由工厂类来负责对象创建的工作。那它们之间有什么区别呢？
2. 实际上，工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象

网上有一个经典的例子很好地解释了两者的区别:
>顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。

### 应用场景
- 需要生成的产品对象有复杂的内部结构，这些产品对象具备共性；
- 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。

### 本质
- 用户只需要给出指定复杂对象的类型和内容；
- 建造者模式负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来）

### 解决的问题
1. 降低创建复杂对象的复杂度
2. 隔离了创建对象的构建过程 & 表示
从而：

方便用户创建复杂的对象（不需要知道实现过程）
代码复用性 & 封装性（将对象构建过程和细节进行封装 & 复用）

### 结构
1. 生成器的接口定义
```java
/**
   * 生成器接口，定义创建一个产品对象所需的各个部件的操作
   */
public interface Builder {
    /**
     * 示意方法，构建某个部件
     */
    public void buildPart();
}
```
2. 再看看具体的生成器实现，示例代码如下：
```java
/**
   * 具体的生成器实现对象
   */
public class ConcreteBuilder implements Builder {
    /**
     * 生成器最终构建的产品对象
     */
    private Product resultProduct;
    /**
     * 获取生成器最终构建的产品对象
     * @return 生成器最终构建的产品对象
     */
    public Product getResult() {
       return resultProduct;
    }

    public void buildPart() {
       //构建某个部件的功能处理
    }
}
```
3. 看看相应的产品对象的接口示意，示例代码如下：
```java
/**
   * 被构建的产品对象的接口
   */
public interface Product {
    //定义产品的操作
}
```
4. 再来看看指导者的实现示意，示例代码如下：
```java
/**
   * 指导者，指导使用生成器的接口来构建产品的对象
   */
public class Director {
    /**
     * 持有当前需要使用的生成器对象
     */
    private Builder builder;

    /**
     * 构造方法，传入生成器对象
     * @param builder 生成器对象
     */
    public Director(Builder builder) {
       this.builder = builder;
    }

    /**
     * 示意方法，指导生成器构建最终的产品对象
     */
    public void construct() {
       //通过使用生成器接口来构建最终的产品对象
       builder.buildPart();
    }
}
```
### 实例
先来看看定义的Builder接口，主要是把导出各种格式文件的处理过程的步骤定义出来，每个步骤负责构建最终导出文件的一部分。示例代码如下：
```java
/**
   * 生成器接口，定义创建一个输出文件对象所需的各个部件的操作
   */
public interface Builder {
    /**
     * 构建输出文件的Header部分
     * @param ehm 文件头的内容
     */
    public void buildHeader(ExportHeaderModel ehm);
    /**
     * 构建输出文件的Body部分
     * @param mapData 要输出的数据的内容
     */
    public void buildBody(Map<String,Collection<ExportDataModel>> mapData);
    /**
     * 构建输出文件的Footer部分
     * @param efm 文件尾的内容
     */
    public void buildFooter(ExportFooterModel efm);
}
```
接下来看看具体的生成器实现，其实就是把原来示例中，写在一起的实现，分拆成多个步骤实现了，先看看导出数据到文本文件的生成器实现，示例代码如下：
```java
/**
   * 实现导出数据到文本文件的的生成器对象
   */
public class TxtBuilder implements Builder {
    /**
     * 用来记录构建的文件的内容，相当于产品
     */
    private StringBuffer buffer = new StringBuffer();

    public void buildBody(Map<String, Collection<ExportDataModel>> mapData) {
       for(String tblName : mapData.keySet()){
           //先拼接表名称
           buffer.append(tblName+"\n");
           //然后循环拼接具体数据
           for(ExportDataModel edm : mapData.get(tblName)){
              buffer.append(edm.getProductId()+","+edm.getPrice()+","+edm.getAmount()+"\n");
           }
       }
    }
    public void buildFooter(ExportFooterModel efm) {
       buffer.append(efm.getExportUser());
    }
    public void buildHeader(ExportHeaderModel ehm) {
       buffer.append(ehm.getDepId()+","+ehm.getExportDate()+"\n");
    }  
    public StringBuffer getResult(){
       return buffer;
    }   
}
```
再看看导出数据到XML文件的生成器实现，示例代码如下：
```java
/**
   * 实现导出数据到XML文件的的生成器对象
   */
public class XmlBuilder implements Builder {
    /**
     * 用来记录构建的文件的内容，相当于产品
     */
    private StringBuffer buffer = new StringBuffer();

    public void buildBody(Map<String, Collection<ExportDataModel>> mapData){
       buffer.append("  <Body>\n");
       for(String tblName : mapData.keySet()){
           //先拼接表名称
           buffer.append("    <Datas TableName=\""+tblName+"\">\n");
           //然后循环拼接具体数据
           for(ExportDataModel edm : mapData.get(tblName)){
              buffer.append("      <Data>\n");
              buffer.append("        <ProductId>"+edm.getProductId()+"</ProductId>\n");
              buffer.append("        <Price>"+edm.getPrice()+"</Price>\n");
              buffer.append("        <Amount>"+edm.getAmount()+"</Amount>\n");
              buffer.append("      </Data>\n");
           }
           buffer.append("    </Datas>\n");
       }
       buffer.append("  </Body>\n");
    }
    public void buildFooter(ExportFooterModel efm) {
       buffer.append("  <Footer>\n");
       buffer.append("    <ExportUser>"+efm.getExportUser()+"</ExportUser>\n");
       buffer.append("  </Footer>\n");
       buffer.append("</Report>\n");
    }
    public void buildHeader(ExportHeaderModel ehm) {
       buffer.append("<?xml version='1.0' encoding='gb2312'?>\n");
       buffer.append("<Report>\n");
       buffer.append("  <Header>\n");
       buffer.append("    <DepId>"+ehm.getDepId()+"</DepId>\n");
       buffer.append("    <ExportDate>"+ehm.getExportDate()+"</ExportDate>\n");
       buffer.append("  </Header>\n");
    }
    public StringBuffer getResult(){
       return buffer;
    }
}
```
指导者
有了具体的生成器实现后，需要有指导者来指导它进行具体的产品构建，由于构建的产品是文本内容，所以就不用单独定义产品对象了。示例代码如下：
```java
/**
   * 指导者，指导使用生成器的接口来构建输出的文件的对象
   */
public class Director {
    /**
     * 持有当前需要使用的生成器对象
     */
    private Builder builder;
    /**
     * 构造方法，传入生成器对象
     * @param builder 生成器对象
     */
    public Director(Builder builder) {
       this.builder = builder;
    }

    /**
     * 指导生成器构建最终的输出的文件的对象
     * @param ehm 文件头的内容
     * @param mapData 数据的内容
     * @param efm 文件尾的内容
     */
    public void construct(ExportHeaderModel ehm,Map<String,Collection<ExportDataModel>> mapData,ExportFooterModel efm) {
       //1：先构建Header
       builder.buildHeader(ehm);
       //2：然后构建Body
       builder.buildBody(mapData);
       //3：然后构建Footer
       builder.buildFooter(efm);
    }
}
```
都实现得差不多了，该来写个客户端好好测试一下了。示例代码如下：
```java
public class Client {
    public static void main(String[] args) {
       //准备测试数据
       ExportHeaderModel ehm = new ExportHeaderModel();
       ehm.setDepId("一分公司");
       ehm.setExportDate("2010-05-18");

       Map<String,Collection<ExportDataModel>> mapData = new HashMap<String,Collection<ExportDataModel>>();
       Collection<ExportDataModel> col = new ArrayList<ExportDataModel>();

       ExportDataModel edm1 = new ExportDataModel();
       edm1.setProductId("产品001号");
       edm1.setPrice(100);
       edm1.setAmount(80);

       ExportDataModel edm2 = new ExportDataModel();
       edm2.setProductId("产品002号");
       edm2.setPrice(99);
       edm2.setAmount(55);     
       //把数据组装起来
       col.add(edm1);
       col.add(edm2);      
       mapData.put("销售记录表", col);

       ExportFooterModel efm = new ExportFooterModel();
       efm.setExportUser("张三");

       //测试输出到文本文件
       TxtBuilder txtBuilder = new TxtBuilder();
       //创建指导者对象
       Director director = new Director(txtBuilder);
       director.construct(ehm, mapData, efm);
       //把要输出的内容输出到控制台看看
       System.out.println("输出到文本文件的内容：\n"+txtBuilder.getResult());
       //测试输出到xml文件
       XmlBuilder xmlBuilder = new XmlBuilder();
       Director director2 = new Director(xmlBuilder);
       director2.construct(ehm, mapData, efm);
       //把要输出的内容输出到控制台看看
       System.out.println("输出到XML文件的内容：\n"+xmlBuilder.getResult());
    }
}
```